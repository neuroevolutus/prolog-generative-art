:- module('generate_pixmaps', [main/0]).

%% Procedurally generate grayscale images using the ASCII portable
%% graymap format.
%% See https://en.wikipedia.org/wiki/Netpbm for more details.

% The first image is generated by keeping a counter that increments with
% each pixel being output and producing a value in the range [0, 255]
% using a determinstic predicate on the counter.
% The second image is generated by using a determinstic predicate on the
% x- and y-coordinates of each pixel to generate a value in the range
% [0, 255].
main :-
    open('grayscale_seq.pgm', write, OutStream1),
    open('grayscale_pos.pgm', write, OutStream2),
    phrase(grayscale_image_seq(500, 500, 255), GrayscaleImageSeqCodes),
    phrase(grayscale_image_pos(500, 500, 255), GrayscaleImagePosCodes),
    atom_codes(GrayscaleImageSeq, GrayscaleImageSeqCodes),
    atom_codes(GrayscaleImagePos, GrayscaleImagePosCodes),
    write(OutStream1, GrayscaleImageSeq),
    write(OutStream2, GrayscaleImagePos),
    close(OutStream2),
    close(OutStream1).

% The text header for every ASCII PGM image is the same.
p2Header(Width, Height, MaxValue) -->
    { maplist(
          atom_codes,
          ['P2', Width, Height, MaxValue],
          [P2Codes, WidthCodes, HeightCodes, MaxValueCodes]
      )
    },
    P2Codes,
    [32],
    WidthCodes,
    [32],
    HeightCodes,
    [32],
    MaxValueCodes,
    [32].

grayscale_image_seq(Width, Height, MaxValue) -->
    { NumGrayscalePixels is Width * Height },
    p2Header(Width, Height, MaxValue),
    grayscale_pixels_seq(NumGrayscalePixels, MaxValue).

grayscale_image_pos(Width, Height, MaxValue) -->
    p2Header(Width, Height, MaxValue),
    grayscale_pixels_pos(Width, Height, MaxValue, 1, 1).

grayscale_pixels_seq(NumGrayscalePixels, MaxValue) --> grayscale_pixels_seq(NumGrayscalePixels, MaxValue, start(50)).

grayscale_pixels_seq(0, _, _) --> [].
grayscale_pixels_seq(N, MaxValue, start(InitialGrayscalePixel)) -->
    { N > 0, % Prevents overlap with the first rule
      NLess is N - 1,
      atom_codes(InitialGrayscalePixel, GrayscalePixelCodes)
    },
    GrayscalePixelCodes,
    grayscale_pixels_seq(NLess, MaxValue, InitialGrayscalePixel).
grayscale_pixels_seq(N, MaxValue, OldGrayscalePixel) -->
    [32],
    { OldGrayscalePixel \= start(_), % prevents overlap with the second rule
      N > 0, % Prevents overlap with the first rule
      NLess is N - 1,
      transform(OldGrayscalePixel, NewGrayscalePixel, MaxValue),
      atom_codes(NewGrayscalePixel, NewGrayscalePixelCodes)
    },
    NewGrayscalePixelCodes,
    grayscale_pixels_seq(NLess, MaxValue, NewGrayscalePixel).

grayscale_pixels_pos(_, Height, _, _, Y) --> { Y =:= Height + 1 }, [].
grayscale_pixels_pos(Width, Height, MaxValue, 1, 1) -->
    { Width >= 1,
      Height >= 1,
      grayscalePixel(1, 1, MaxValue, GrayscalePixel),
      atom_codes(GrayscalePixel, GrayscalePixelCodes)
    },
    GrayscalePixelCodes,
    grayscale_pixels_pos(Width, Height, MaxValue, 2, 1).
grayscale_pixels_pos(Width, Height, MaxValue, X, Y) -->
    { X =:= Width + 1,
      Y =< Height,
      NewY is Y + 1
    },
    grayscale_pixels_pos(Width, Height, MaxValue, 1, NewY).
grayscale_pixels_pos(Width, Height, MaxValue, X, Y) -->
    [32],
    { X =< Width,
      Y =< Height,
      \+ (X = 1, Y = 1), % Prevents overlap with the second rule
      NewX is X + 1,
      grayscalePixel(X, Y, MaxValue, GrayscalePixel),
      atom_codes(GrayscalePixel, GrayscalePixelCodes)
    },
    GrayscalePixelCodes,
    grayscale_pixels_pos(Width, Height, MaxValue, NewX, Y).

grayscalePixel(X, Y, MaxValue, GrayscalePixel) :-
    XSquared is X ** 2,
    YCubed is Y ** 3,
    Temp is (XSquared * 3 + YCubed * 97 + 97) * 3,
    divmod(Temp, MaxValue, _, GrayscalePixel).

transform(OldGrayscalePixel, NewGrayscalePixel, MaxValue) :-
    Temp is (OldGrayscalePixel * 97 + 97) * 3,
    divmod(Temp, MaxValue, _, NewGrayscalePixel).
